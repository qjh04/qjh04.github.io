<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">




<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

  <meta name="author" content="jiahe">


  <meta name="subtitle" content="待到山花烂漫时...">


  <meta name="description" content="一个在github上搭建的个人博客">



<title>Netty | 个人学习博客</title>



<link rel="icon" href="/favicon.png">



<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/nprogress/nprogress.css">



<script src="/lib/jquery.min.js"></script>


<script src="/lib/iconify-icon.min.js"></script>


<script src="https://cdn.tailwindcss.com?plugins=typography"></script>
<script>
  tailwind.config = {
    darkMode: "class",
  };
</script>


<script src="/lib/nprogress/nprogress.js"></script>

<script>
  $(document).ready(() => {
    NProgress.configure({
      showSpinner: false,
    });
    NProgress.start();
    $("#nprogress .bar").css({
      background: "#de7441",
    });
    $("#nprogress .peg").css({
      "box-shadow": "0 0 2px #de7441, 0 0 4px #de7441",
    });
    $("#nprogress .spinner-icon").css({
      "border-top-color": "#de7441",
      "border-left-color": "#de7441",
    });
    setTimeout(function () {
      NProgress.done();
      $(".fade").removeClass("out");
    }, 800);
  });
</script>

<script>
  (function () {
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const setting = localStorage.getItem("hexo-color-scheme") || "auto";
    if (setting === "dark" || (prefersDark && setting !== "light"))
      document.documentElement.classList.toggle("dark", true);
    let isDark = document.documentElement.classList.contains("dark");
  })();

  $(document).ready(function () {
    // init icon
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const isDark = document.documentElement.classList.contains("dark");
    $("#theme-icon").attr("icon", isDark ? "ri:moon-line" : "ri:sun-line");

    function toggleGiscusTheme() {
      const isDark = document.documentElement.classList.contains("dark");
      const giscusFrame = document.querySelector("iframe.giscus-frame");
      if (giscusFrame) {
        giscusFrame.contentWindow.postMessage(
          {
            giscus: {
              setConfig: {
                theme: isDark ? "dark" : "light",
              },
            },
          },
          "https://giscus.app"
        );
      }
    }


    // toggle dark mode
    function toggleDark() {
      let isDark = document.documentElement.classList.contains("dark");
      const setting = localStorage.getItem("hexo-color-scheme") || "auto";
      isDark = !isDark;
      document.documentElement.classList.toggle("dark", isDark);
      $("#theme-icon").attr("icon", isDark ? "ri:moon-line" : "ri:sun-line");
      if (prefersDark === isDark) {
        localStorage.setItem("hexo-color-scheme", "auto");
      } else {
        localStorage.setItem("hexo-color-scheme", isDark ? "dark" : "light");
      }
      toggleGiscusTheme();
    }
    $("#toggle-dark").click(toggleDark);

    // listen dark mode change
    window
      .matchMedia("(prefers-color-scheme: dark)")
      .addEventListener("change", (e) => {
        const setting = localStorage.getItem("hexo-color-scheme") || "auto";
        if (setting === "auto") {
          document.documentElement.classList.toggle("dark", e.matches);
          $("#theme-icon").attr(
            "icon",
            e.matches ? "ri:moon-line" : "ri:sun-line"
          );
          toggleGiscusTheme();
        }
      });
  });
</script>




<meta name="generator" content="Hexo 7.2.0"></head>
<body class="font-sans bg-white dark:bg-zinc-900 text-gray-700 dark:text-gray-200 relative">
  <header class="fixed w-full px-5 py-1 z-10 backdrop-blur-xl backdrop-saturate-150 border-b border-black/5">
  <div class="max-auto">
    <nav class="flex items-center text-base">
      <a href="/" class="group">
        <h2 class="font-medium tracking-tighterp text-l p-2">
          <img class="w-5 mr-2 inline-block transition-transform group-hover:rotate-[30deg]" id="logo" src="/images/logo.svg" alt="个人学习博客" />
          个人学习博客
        </h2>
      </a>
      <div id="header-title" class="opacity-0 md:ml-2 md:mt-[0.1rem] text-xs font-medium whitespace-nowrap overflow-hidden overflow-ellipsis">
        Netty
      </div>
      <div class="flex-1"></div>
      <div class="flex items-center gap-3">
        
          <a class="hidden sm:flex" href="/archives">Posts</a>
        
        
          
            <a class="w-5 h-5 hidden sm:flex" title="Github" target="_blank" rel="noopener" href="https://github.com/qjh04">
              <iconify-icon width="20" icon="ri:github-line"></iconify-icon>
            </a>
          
        
        <a class="w-5 h-5 hidden sm:flex" title="Github" href="rss2.xml">
          <iconify-icon width="20" icon="ri:rss-line"></iconify-icon>
        </a>
        <a class="w-5 h-5" title="toggle theme" id="toggle-dark">
          <iconify-icon width="20" icon="" id="theme-icon"></iconify-icon>
        </a>
      </div>
      <div class="flex items-center justify-center gap-3 ml-3 sm:hidden">
        <span class="w-5 h-5" aria-hidden="true" role="img" id="open-menu">
          <iconify-icon width="20" icon="carbon:menu" ></iconify-icon>
        </span>
        <span class="w-5 h-5 hidden" aria-hidden="true" role="img" id="close-menu">
          <iconify-icon  width="20" icon="carbon:close" ></iconify-icon>
        </span>
      </div>
    </nav>
  </div>
</header>
<div id="menu-panel" class="h-0 overflow-hidden sm:hidden fixed left-0 right-0 top-12 bottom-0 z-10">
  <div id="menu-content" class="relative z-20 bg-white/80 px-6 sm:px-8 py-2 backdrop-blur-xl -translate-y-full transition-transform duration-300">
    <ul class="nav flex flex-col sm:flex-row text-sm font-medium">
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/archives" class="flex h-12 sm:h-auto items-center">Posts</a>
        </li>
      
    </ul>
  </div>
  <div class="mask bg-black/20 absolute inset-0"></div>
</div>

  <main class="pt-14">
    <!-- css -->

<link rel="stylesheet" href="/lib/fancybox/fancybox.min.css">


<link rel="stylesheet" href="/lib/tocbot/tocbot.min.css">

<!-- toc -->

  <!-- tocbot -->
<nav class="post-toc toc text-sm w-48 relative top-32 right-0 opacity-70 hidden lg:block" style="position: fixed !important;"></nav>


<section class="px-6 max-w-prose mx-auto md:px-0">
  <!-- header -->
  <header class="overflow-hidden pt-6 pb-6 md:pt-12">
    <div class="pt-4 md:pt-6">
      <h1 id="article-title" class="text-[2rem] font-bold leading-snug mb-4 md:mb-6 md:text-[2.6rem]">
        Netty
      </h1>
      <div>
        <section class="flex items-center gap-3 text-sm">
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="carbon-calendar" ></iconify-icon>
            <time>2025-01-11</time>
          </span>
          <span class="text-gray-400">·</span>
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="ic:round-access-alarm" ></iconify-icon>
            <span>46 min</span>
          </span>
          <span class="text-gray-400">·</span>
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="icon-park-outline:font-search" ></iconify-icon>
            <span>12k words</span>
          </span>
                  
        </section>
      </div>
    </div>
  </header>
  <!-- content -->
  <article class="post-content prose m-auto slide-enter-content dark:prose-invert">
    <h2 id="第一章-NIO基础"><a href="#第一章-NIO基础" class="headerlink" title="第一章 NIO基础"></a>第一章 NIO基础</h2><h3 id="1-三大组件"><a href="#1-三大组件" class="headerlink" title="1.  三大组件"></a>1.  三大组件</h3><h4 id="1-1-Channel与Buffer"><a href="#1-1-Channel与Buffer" class="headerlink" title="1.1 Channel与Buffer"></a>1.1 Channel与Buffer</h4><p>Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理</p>
<p>简而言之，通道负责传输，缓冲区负责存储</p>
<p>常见的Channel有以下四种，其中FileChannel主要用于文件传输，其余三种用于网络通信</p>
<ul>
<li><p>FileChannel</p>
</li>
<li><p>DatagramChannel</p>
</li>
<li><p>SocketChannel</p>
</li>
<li><p>ServerSocketChannel</p>
</li>
<li><p>Buffer有以下几种，其中使用较多的是ByteBuffer</p>
</li>
</ul>
<p>Buffer有以下几种，其中使用较多的是ByteBuffer</p>
<ul>
<li>ByteBuffer（抽象类）<ul>
<li>MappedByteBuffer</li>
<li>DirectByteBuffer</li>
<li>HeapByteBuffer</li>
</ul>
</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
<li>CharBuffer</li>
</ul>
<h4 id="1-2-selector"><a href="#1-2-selector" class="headerlink" title="1.2 selector"></a>1.2 selector</h4><p>在使用Selector之前，处理socket连接还有以下两种方法</p>
<p>使用多线程技术</p>
<p>为每个连接分别开辟一个线程，分别去处理对应的socke连接</p>
<p>这种方法存在以下几个问题</p>
<ul>
<li>内存占用高，每个线程都需要占用一定的内存，当连接较多时，会开辟大量线程，导致占用大量内存</li>
<li>线程上下文切换成本高</li>
<li>只适合连接数少的场景，连接数过多，会导致创建很多线程，从而出现问题</li>
</ul>
<p>使用线程池技术</p>
<p>使用线程池，让线程池中的线程去处理连接</p>
<p>这种方法存在以下几个问题</p>
<ul>
<li><p>阻塞模式下，线程仅能处理一个连接</p>
<ul>
<li>线程池中的线程获取任务（task）后，只有当其执行完任务之后（断开连接后），才会去获取并执行下一个任务</li>
<li>若socke连接一直未断开，则其对应的线程无法处理其他socke连接</li>
</ul>
</li>
<li><p>仅适合短连接场景，短连接即建立连接发送请求并响应后就立即断开，使得线程池中的线程可以快速处理其他连接</p>
</li>
</ul>
<p>使用选择器技术</p>
<p>selector 的作用就是配合一个线程来管理多个 channel（fileChannel因为是阻塞式的，所以无法使用selector），获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，当一个channel中没有执行任务时，可以去执行其他channel中的任务。适合连接数多，但流量较少的场景</p>
<p>若事件未就绪，调用 selector 的 select() 方法会阻塞线程，直到 channel 发生了就绪事件。这些事件就绪后，select 方法就会返回这些事件交给 thread 来处理</p>
<h4 id="1-3-bytebuffer使用方法"><a href="#1-3-bytebuffer使用方法" class="headerlink" title="1.3 bytebuffer使用方法"></a>1.3 bytebuffer使用方法</h4><ol>
<li><p>向 buffer 写入数据，例如调用 channel.read(buffer)</p>
</li>
<li><p>调用 flip() 切换至读模式</p>
<ol>
<li>flip会使得buffer中的limit变为position</li>
<li>position变为0</li>
<li>从 buffer 读取数据，例如调用 buffer.get()</li>
</ol>
</li>
<li><p>调用 clear() 或者compact()切换至写模式</p>
<ol>
<li>调用clear()方法时position&#x3D;0</li>
<li>limit变为capacity</li>
<li>调用compact()方法时</li>
<li>会将缓冲区中的未读数据压缩到缓冲区前面</li>
</ol>
</li>
<li><p>重复以上步骤</p>
</li>
</ol>
<h5 id="1-3-1-核心属性"><a href="#1-3-1-核心属性" class="headerlink" title="1.3.1 核心属性"></a>1.3.1 核心属性</h5><ul>
<li>capacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li>
<li>limit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量</li>
<li>position：下一个读写位置的索引（类似PC）。缓冲区的位置不能为负，并且不能大于limit</li>
<li>mark：记录当前position的值。position被改变后，可以通过调用reset() 方法恢复到mark的位置。</li>
</ul>
<h5 id="1-3-2-核心方法"><a href="#1-3-2-核心方法" class="headerlink" title="1.3.2 核心方法"></a>1.3.2 核心方法</h5><ul>
<li>put()方法<ul>
<li>put()方法可以将一个数据放入到缓冲区中。</li>
<li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity &#x3D; limit ，为缓冲区容量的值。</li>
</ul>
</li>
<li>flip()方法<ul>
<li>flip()方法会切换对缓冲区的操作模式，由写-&gt;读 &#x2F; 读-&gt;写</li>
<li>进行该操作后<ul>
<li>如果是写模式-&gt;读模式，position &#x3D; 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li>
<li>如果是读-&gt;写，则恢复为put()方法中的值</li>
</ul>
</li>
</ul>
</li>
<li>get()方法<ul>
<li>get()方法会读取缓冲区中的一个值</li>
<li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li>
<li>注意：get(i)方法不会改变position的值</li>
</ul>
</li>
<li>rewind()方法<ul>
<li>该方法只能在读模式下使用</li>
<li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li>
</ul>
</li>
<li>clean()方法<ul>
<li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position &#x3D; 0, capacity &#x3D; limit</li>
<li>此时缓冲区的数据依然存在，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li>
</ul>
</li>
<li>mark()和reset()方法<ul>
<li>mark()方法会将postion的值保存到mark属性中</li>
<li>reset()方法会将position的值改为mark中保存的值</li>
</ul>
</li>
<li>compact()方法<ul>
<li>此方法为ByteBuffer的方法，而不是Buffer的方法</li>
<li>compact会把未读完的数据向前压缩，然后切换到写模式</li>
<li>数据前移后，原位置的值并未清零，写时会覆盖之前的值</li>
</ul>
</li>
</ul>
<h5 id="1-3-3-clear-VS-compact"><a href="#1-3-3-clear-VS-compact" class="headerlink" title="1.3.3 clear() VS compact()"></a>1.3.3 clear() VS compact()</h5><p>clear只是对position、limit、mark进行重置，而compact在对position进行设置，以及limit、mark进行重置的同时，还涉及到数据在内存中拷贝（会调用arraycopy）。所以compact比clear更耗性能。但compact能保存你未读取的数据，将新数据追加到为读取的数据之后；而clear则不行，若你调用了clear，则未读取的数据就无法再读取到了</p>
<h5 id="1-3-4-字符串与bytebuffer相转换"><a href="#1-3-4-字符串与bytebuffer相转换" class="headerlink" title="1.3.4 字符串与bytebuffer相转换"></a>1.3.4 字符串与bytebuffer相转换</h5><ul>
<li>方法一：<ul>
<li>编码：字符串调用getByte方法获得byte数组，将byte数组放入ByteBuffer中</li>
<li>解码：先调用ByteBuffer的flip方法，然后通过StandardCharsets的decoder方法解码</li>
</ul>
</li>
<li>方法二：<ul>
<li>编码：通过StandardCharsets的encode方法获得ByteBuffer，此时获得的ByteBuffer为读模式，无需通过flip切换模式</li>
<li>解码：通过StandardCharsets的decoder方法解码</li>
</ul>
</li>
<li>方法三：<ul>
<li>编码：字符串调用getByte()方法获得字节数组，将·字节数组传给ByteBuffer的wrap()方法，通过该方法获得ByteBuffer。同样无需调用flip方法切换为读模式</li>
<li>解码：通过StandardCharsets的decoder方法解码</li>
</ul>
</li>
</ul>
<h4 id="1-4-粘包与半包"><a href="#1-4-粘包与半包" class="headerlink" title="1.4 粘包与半包"></a>1.4 粘包与半包</h4><ul>
<li>出现原因<ul>
<li>粘包：发送方在发送数据时，并不是一条一条地发送数据，而是将数据整合在一起，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去</li>
<li>半包：接收方的缓冲区的大小是有限的，当接收方的缓冲区满了以后，就需要将信息截断，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象</li>
</ul>
</li>
</ul>
<h3 id="2-文件编程（了解）"><a href="#2-文件编程（了解）" class="headerlink" title="2. 文件编程（了解）"></a>2. 文件编程（了解）</h3><h4 id="2-1-FileChannel"><a href="#2-1-FileChannel" class="headerlink" title="2.1 FileChannel"></a>2.1 FileChannel</h4><p>工作模式：FileChannel只能在阻塞模式下工作，所以无法搭配Selector</p>
<h5 id="2-1-1-获取"><a href="#2-1-1-获取" class="headerlink" title="2.1.1 获取"></a>2.1.1 获取</h5><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p>
<ul>
<li>通过 FileInputStream 获取的 channel 只能读</li>
<li>通过 FileOutputStream 获取的 channel 只能写</li>
<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li>
</ul>
<h5 id="2-1-2-读取"><a href="#2-1-2-读取" class="headerlink" title="2.1.2 读取"></a>2.1.2 读取</h5><ol>
<li>通过 FileInputStream 获取channel，通过read方法将数据写入到ByteBuffer中</li>
<li>read方法的返回值表示读到了多少字节，若读到了文件末尾则返回-1</li>
</ol>
<h5 id="2-1-3-写入"><a href="#2-1-3-写入" class="headerlink" title="2.1.3 写入"></a>2.1.3 写入</h5><p>因为channel也是有大小的，所以 write 方法并不能保证一次将 buffer 中的内容全部写入 channel。必须需要通过hasRemaining()方法查看缓冲区中是否还有数据未写入到通道中进行写入</p>
<h5 id="2-1-4-关闭"><a href="#2-1-4-关闭" class="headerlink" title="2.1.4 关闭"></a>2.1.4 关闭</h5><p>通道需要close，一般情况通过try-with-resource进行关闭，最好使用以下方法获取strea以及channel，避免某些原因使得资源未被关闭</p>
<h5 id="2-1-5-位置"><a href="#2-1-5-位置" class="headerlink" title="2.1.5 位置"></a>2.1.5 位置</h5><ul>
<li>channel也拥有一个保存读取数据位置的属性，即position</li>
<li>可以通过position(int pos)设置channel中position的值<ul>
<li>设置当前位置时，如果设置为文件的末尾<ul>
<li>这时读取会返回 -1</li>
<li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-1-6-强制写入"><a href="#2-1-6-强制写入" class="headerlink" title="2.1.6 强制写入"></a>2.1.6 强制写入</h5><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘，而是等到缓存满了以后将所有数据一次性的写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p>
<h4 id="2-2-两个channel传输数据"><a href="#2-2-两个channel传输数据" class="headerlink" title="2.2 两个channel传输数据"></a>2.2 两个channel传输数据</h4><p>使用transferTo方法可以快速、高效地将一个channel中的数据传输到另一个channel中，但一次只能传输2G的内容，transferTo底层使用了零拷贝技术</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意当传输的文件大于2G时，需要使用以下方法进行多次传输</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChannel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;stu.txt&quot;</span>);</span><br><span class="line">             <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">             <span class="type">FileChannel</span> <span class="variable">inputChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">             <span class="type">FileChannel</span> <span class="variable">outputChannel</span> <span class="operator">=</span> fos.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 参数：inputChannel的起始位置，传输数据的大小，目的channel</span></span><br><span class="line">            <span class="comment">// 返回值为传输的数据的字节数</span></span><br><span class="line">            <span class="comment">// transferTo一次只能传输2G的数据</span></span><br><span class="line">            inputChannel.transferTo(<span class="number">0</span>, inputChannel.size(), outputChannel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-Path、Paths与Files"><a href="#2-3-Path、Paths与Files" class="headerlink" title="2.3 Path、Paths与Files"></a>2.3 Path、Paths与Files</h4><ul>
<li>Path 用来表示文件路径</li>
<li>Paths 是工具类，用来获取 Path 实例</li>
<li>Files 用于操作文件的工具类有以下方法<ul>
<li>查找：get（Path）</li>
<li>创建：createDirectory（Path）、createDirectories（Path）</li>
<li>拷贝：copy（Path, Path ）</li>
<li>移动：move（Path, Path）</li>
<li>删除：delete（Path） 如果文件不存在或目录有文件 会抛异常</li>
<li>遍历：walkFileTree(Path, FileVisitor)<ul>
<li>Path：文件起始路径</li>
<li>FileVisitor：文件访问器，使用访问者模式<ul>
<li>接口的实现类：SimpleFileVisitor 有四个方法<ul>
<li>preVisitDirectory：访问目录前的操作</li>
<li>visitFile：访问文件的操作</li>
<li>visitFileFailed：访问文件失败时的操作</li>
<li>postVisitDirectory：访问目录后的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码作用：遍历文件目录 输出文件目录名称与数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWalkFileTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\JDK 8&quot;</span>);</span><br><span class="line">        <span class="comment">// 文件目录数目</span></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">dirCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="comment">// 文件数目</span></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;===&gt;&quot;</span>+dir);</span><br><span class="line">                <span class="comment">// 增加文件目录数</span></span><br><span class="line">                dirCount.incrementAndGet();</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">                <span class="comment">// 增加文件数</span></span><br><span class="line">                fileCount.incrementAndGet();</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 打印数目</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件目录数:&quot;</span>+dirCount.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件数:&quot;</span>+fileCount.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-网络编程"><a href="#3-网络编程" class="headerlink" title="3. 网络编程"></a>3. 网络编程</h3><h4 id="3-1-阻塞"><a href="#3-1-阻塞" class="headerlink" title="3.1 阻塞"></a>3.1 阻塞</h4><p>阻塞模式下，相关方法都会导致线程暂停</p>
<ul>
<li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li>
<li>SocketChannel.read 会在通道中没有数据可读时让线程暂停</li>
</ul>
<p>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置，不能处理其他的任务</p>
<ul>
<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>
<li>但多线程下，有新的问题，体现在以下方面。32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
</ul>
<p>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</p>
<h4 id="3-2-非阻塞"><a href="#3-2-非阻塞" class="headerlink" title="3.2 非阻塞"></a>3.2 非阻塞</h4><ul>
<li>可以通过ServerSocketChannel的configureBlocking(false)方法将获得连接设置为非阻塞的。此时若没有连接，accept会返回null</li>
<li>可以通过SocketChannel的configureBlocking(false)方法将从通道中读取数据设置为非阻塞的。若此时通道中没有数据可读，read会返回-1</li>
</ul>
<p>这样写存在一个问题，因为设置为了非阻塞，会一直执行while(true)中的代码，CPU一直处于忙碌状态，会使得性能变低，所以实际情况中不使用这种方法处理请求</p>
<h4 id="3-3-Selector"><a href="#3-3-Selector" class="headerlink" title="3.3 Selector"></a>3.3 Selector</h4><p>多路复用<br>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>
<ul>
<li>多路复用仅针对网络 IO，普通文件 IO 无法利用多路复用</li>
<li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入<ul>
<li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-4-Accpet事件"><a href="#3-4-Accpet事件" class="headerlink" title="3.4 Accpet事件"></a>3.4 Accpet事件</h4><p>步骤：</p>
<ul>
<li><p>获得选择器Selector</p>
</li>
<li><p>将通道设置为非阻塞模式，并注册到选择器中，并设置感兴趣的事件</p>
<ul>
<li><p>channel 必须工作在非阻塞模式</p>
</li>
<li><p>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</p>
</li>
<li><p>绑定的事件类型可以有：</p>
<ul>
<li>connect - 客户端连接成功时触发</li>
<li>accept - 服务器端成功接受连接时触发</li>
<li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li>
<li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>
</ul>
</li>
</ul>
</li>
<li><p>通过Selector监听事件，并获得就绪的通道个数，若没有通道就绪，线程会被阻塞</p>
<ul>
<li><p>阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p>
</li>
<li><p>不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p>
</li>
</ul>
</li>
<li><p>获取就绪事件并得到对应的通道，然后进行处理</p>
</li>
<li><p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p>
</li>
</ul>
<h4 id="3-5-Read事件"><a href="#3-5-Read事件" class="headerlink" title="3.5 Read事件"></a>3.5 Read事件</h4><ul>
<li>在Accept事件中，若有客户端与服务器端建立了连接，需要将其对应的SocketChannel设置为非阻塞，并注册到选择其中</li>
<li>添加Read事件，触发后进行读取操作</li>
<li>当处理完一个事件后，一定要调用迭代器的remove方法移除事件集合中的对应事件，否则会出现错误</li>
</ul>
<h5 id="3-5-1-断开处理"><a href="#3-5-1-断开处理" class="headerlink" title="3.5.1 断开处理"></a>3.5.1 断开处理</h5><p>当客户端与服务器之间的连接断开时，会给服务器端发送一个读事件，对异常断开和正常断开需要加以不同的方式进行处理</p>
<ul>
<li><p>正常断开</p>
<ul>
<li>正常断开时，服务器端的channel.read(buffer)方法的返回值为-1，所以当结束到返回值为-1时，需要调用key的cancel方法取消此事件，并在取消后移除该事件</li>
</ul>
</li>
<li><p>异常断开</p>
<ul>
<li>异常断开时，会抛出IOException异常， 在try-catch的catch块中捕获异常并调用key的cancel方法即可</li>
</ul>
</li>
</ul>
<h5 id="3-5-2-消息边界"><a href="#3-5-2-消息边界" class="headerlink" title="3.5.2 消息边界"></a>3.5.2 消息边界</h5><p>传输的文本可能有以下三种情况</p>
<ul>
<li>文本大于缓冲区大小<ul>
<li>此时需要将缓冲区进行扩容</li>
</ul>
</li>
<li>发生半包现象</li>
<li>发生粘包现象</li>
</ul>
<p>解决思路大致有以下三种</p>
<ul>
<li><p>固定消息长度，数据包大小一样，服务器按预定长度读取，当发送的数据较少时，需要将数据进行填充，直到长度与消息规定长度一致。缺点是浪费带宽</p>
</li>
<li><p>另一种思路是按分隔符拆分，缺点是效率低，需要一个一个字符地去匹配分隔符</p>
</li>
<li><p>TLV 格式，即 Type 类型、Length 长度、Value 数据（也就是在消息开头用一些空间存放后面数据的长度），如HTTP请求头中的Content-Type与Content-Length。类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量</p>
<ul>
<li>Http 1.1 是 TLV 格式</li>
<li>Http 2.0 是 LTV 格式</li>
</ul>
</li>
</ul>
<p>附件与扩容</p>
<p>Channel的register方法还有第三个参数：<code>附件</code>，可以向其中放入一个Object类型的对象，该对象会与登记的Channel以及其对应的SelectionKey绑定，可以从SelectionKey获取到对应通道的附件</p>
<h5 id="3-5-3-ByteBuffer的大小分配"><a href="#3-5-3-ByteBuffer的大小分配" class="headerlink" title="3.5.3 ByteBuffer的大小分配"></a>3.5.3 ByteBuffer的大小分配</h5><ul>
<li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer</li>
<li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer</li>
<li>分配思路可以参考</li>
<li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能<ul>
<li>参考实现 <a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li>
</ul>
</li>
<li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li>
</ul>
<h4 id="3-6-Write事件"><a href="#3-6-Write事件" class="headerlink" title="3.6 Write事件"></a>3.6 Write事件</h4><p>服务器通过Buffer向通道中写入数据时，可能因为通道容量小于Buffer中的数据大小，导致无法一次性将Buffer中的数据全部写入到Channel中，这时便需要分多次写入，具体步骤如下</p>
<ul>
<li><p>执行一次写操作，向将buffer中的内容写入到SocketChannel中，然后判断Buffer中是否还有数据</p>
</li>
<li><p>若Buffer中还有数据，则需要将SockerChannel注册到Seletor中，并关注写事件，同时将未写完的Buffer作为附件一起放入到SelectionKey中</p>
</li>
<li><p>添加写事件的相关操作 key.isWritable() ，对Buffer再次进行写操作</p>
</li>
<li><p>每次写后需要判断Buffer中是否还有数据（是否写完）。若写完，需要移除SelecionKey中的Buffer附件，避免其占用过多内存，同时还需移除对写事件的关注</p>
</li>
</ul>
<h4 id="3-7-多线程优化"><a href="#3-7-多线程优化" class="headerlink" title="3.7 多线程优化"></a>3.7 多线程优化</h4><p>充分利用多核CPU，分两组选择器</p>
<ul>
<li><p>单线程配一个选择器（Boss），专门处理 accept 事件</p>
</li>
<li><p>创建 cpu 核心数的线程（Worker），每个线程配一个选择器，轮流处理 read 事件</p>
</li>
</ul>
<p>实现思路</p>
<ul>
<li>创建一个负责处理Accept事件的Boss线程，与多个负责处理Read事件的Worker线程</li>
<li>Boss线程执行的操作<ul>
<li>接受并处理Accepet事件，当Accept事件发生后，调用Worker的register(SocketChannel socket)方法，让Worker去处理Read事件，其中需要根据标识robin去判断将任务分配给哪个Worker</li>
<li>register(SocketChannel socket)方法会通过同步队列完成Boss线程与Worker线程之间的通信，让SocketChannel的注册任务被Worker线程执行。添加任务后需要调用selector.wakeup()来唤醒被阻塞的Selector</li>
</ul>
</li>
<li>Worker线程执行的操作<ul>
<li>从同步队列中获取注册任务，并处理Read事件</li>
</ul>
</li>
</ul>
<h3 id="4-NIO与BIO"><a href="#4-NIO与BIO" class="headerlink" title="4. NIO与BIO"></a>4. NIO与BIO</h3><h4 id="4-1-Stream与Channel"><a href="#4-1-Stream与Channel" class="headerlink" title="4.1 Stream与Channel"></a>4.1 Stream与Channel</h4><ul>
<li><p>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</p>
</li>
<li><p>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</p>
</li>
<li><p>二者均为全双工，即读写可以同时进行</p>
<ul>
<li>虽然Stream是单向流动的，但是它也是全双工的</li>
</ul>
</li>
</ul>
<h4 id="4-2-IO模型"><a href="#4-2-IO模型" class="headerlink" title="4.2 IO模型"></a>4.2 IO模型</h4><ul>
<li><p>同步：线程自己去获取结果（一个线程）</p>
<ul>
<li>例如：线程调用一个方法后，需要等待方法返回结果</li>
</ul>
</li>
<li><p>异步：线程自己不去获取结果，而是由其它线程返回结果（至少两个线程）</p>
<ul>
<li>例如：线程A调用一个方法后，继续向下运行，运行结果由线程B返回</li>
</ul>
</li>
</ul>
<p>当调用一次 channel.read 或 stream.read 后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>
<ul>
<li><p>等待数据阶段</p>
</li>
<li><p>复制数据阶段</p>
</li>
</ul>
<h5 id="4-2-1-同步阻塞IO"><a href="#4-2-1-同步阻塞IO" class="headerlink" title="4.2.1 同步阻塞IO"></a>4.2.1 同步阻塞IO</h5><ul>
<li>用户线程进行read操作时，需要等待操作系统执行实际的read操作，此期间用户线程是被阻塞的，无法执行其他操作</li>
</ul>
<h5 id="4-2-2-同步非阻塞IO"><a href="#4-2-2-同步非阻塞IO" class="headerlink" title="4.2.2 同步非阻塞IO"></a>4.2.2 同步非阻塞IO</h5><ul>
<li>用户线程在一个循环中一直调用read方法，若内核空间中还没有数据可读，立即返回</li>
<li>只是在等待阶段非阻塞<ul>
<li>用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果</li>
</ul>
</li>
</ul>
<h5 id="4-2-3-多路复用"><a href="#4-2-3-多路复用" class="headerlink" title="4.2.3 多路复用"></a>4.2.3 多路复用</h5><p>Java中通过Selector实现多路复用</p>
<ul>
<li>当没有事件时，调用select方法会被阻塞住</li>
<li>一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li>
</ul>
<p>多路复用与阻塞IO的区别</p>
<ul>
<li>阻塞IO模式下，若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后，才能去处理read事件</li>
<li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行</li>
</ul>
<h5 id="4-2-4-异步IO（了解）"><a href="#4-2-4-异步IO（了解）" class="headerlink" title="4.2.4 异步IO（了解）"></a>4.2.4 异步IO（了解）</h5><ul>
<li>线程1调用方法后理解返回，不会被阻塞也不需要立即获取结果</li>
<li>当方法的运行结果出来以后，由线程2将结果返回给线程1</li>
</ul>
<h4 id="4-3-零拷贝"><a href="#4-3-零拷贝" class="headerlink" title="4.3 零拷贝"></a>4.3 零拷贝</h4><p>零拷贝指的是数据无需拷贝到 JVM 内存中，同时具有以下三个优点</p>
<ul>
<li>更少的用户态与内核态的切换</li>
<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
<hr>
<h2 id="第二章-Netty入门"><a href="#第二章-Netty入门" class="headerlink" title="第二章 Netty入门"></a>第二章 Netty入门</h2><h3 id="1-什么是Netty"><a href="#1-什么是Netty" class="headerlink" title="1. 什么是Netty"></a>1. 什么是Netty</h3><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>
<p><strong>注意</strong>：Netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</p>
<h3 id="2-Netty的优势"><a href="#2-Netty的优势" class="headerlink" title="2. Netty的优势"></a>2. Netty的优势</h3><p>如果使用传统NIO，其工作量大，bug 多</p>
<ul>
<li>需要自己构建协议</li>
<li>解决 TCP 传输问题，如粘包、半包</li>
<li>因为bug的存在，epoll 空轮询导致 CPU 100%</li>
</ul>
<p>Netty 对 API 进行增强，使之更易用，如</p>
<ul>
<li>FastThreadLocal &#x3D;&gt; ThreadLocal</li>
<li>ByteBuf &#x3D;&gt; ByteBuffer</li>
</ul>
<h3 id="3-入门代码"><a href="#3-入门代码" class="headerlink" title="3. 入门代码"></a>3. 入门代码</h3><p>服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 服务端初始化,是一个启动器，将下面的netty组件组合在一起进行初始化启动</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                <span class="comment">// 添加eventLoop（循环处理事件）的组集合的组件，eventLoop就是nio中的boss以及worker( selector + thread)</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                <span class="comment">// 选择一个ServerSocketChannel的实现，netty支持多种channel，如NIO，BIO,epoll</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">// boss负责处理客户端链接，worker(child)负责处理读写等事件，决定了将来child将来执行那些操作(handler)</span></span><br><span class="line">                .childHandler(</span><br><span class="line">                        <span class="comment">// channel 代表客户端和服务端进行读写的通道，Initialize负责初始化，主要负责添加别的handler</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="comment">// 添加具体的handler</span></span><br><span class="line">                                nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>()); <span class="comment">// 主要是客户端发送过来的数据进行解码handler，将ByteBuf</span></span><br><span class="line">                                <span class="comment">// 添加自定义的handler，处理的内容是上一步的handler处理之后的内容</span></span><br><span class="line">                                nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                                    <span class="comment">// 重写的是读事件</span></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                        System.out.println(<span class="string">&quot;自定义的通道数据处理器，内容：&quot;</span> + msg);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                <span class="comment">// 服务器启动之后绑定监听的端口</span></span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloClient</span> &#123;</span><br><span class="line">        <span class="comment">// 客户端初始化-启动器，将下面的netty组间组合进行初始化</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                <span class="comment">// 进行eventLoop选择器组间集合赋值，此处也可用之前学到的nio模式，不选择也行</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                <span class="comment">// 选择客户端socketChannel连接的实现</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">// 决定了将来连接通道读写事件--worker(child)需要进行的操作</span></span><br><span class="line">                .handler(</span><br><span class="line">                        <span class="comment">// channel 代表客户端和服务端质检读写操作，initializer主要负责初始化，添加别的handler</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="comment">// 添加通道读写事件处理的handler，此处是将字符串--&gt;byteBuf,进行编码</span></span><br><span class="line">                                nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                <span class="comment">// 与服务端建立连接的 ip + port</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8089</span>))</span><br><span class="line">                <span class="comment">// 客户大多数操作都是异步的，连接也是，所以需要使用sync进行等待连接的正常建立</span></span><br><span class="line">                .sync()</span><br><span class="line">                <span class="comment">// 获取到连接通道，可进行数据的读写</span></span><br><span class="line">                .channel()</span><br><span class="line">                <span class="comment">// 向服务端发送消息，并清空缓冲区，如果只适用write，服务端收不到缓冲区中的消息，需要flush</span></span><br><span class="line">                .writeAndFlush(<span class="string">&quot;hello world! netty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件解释</p>
<ul>
<li><p>channel 可以理解为数据的通道</p>
</li>
<li><p>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</p>
</li>
<li><p>handler 可以理解为数据的处理工序</p>
<ul>
<li><p>工序有多道，合在一起就是 pipeline（传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</p>
</li>
<li><p>pipeline 中有多个 handler，处理时会依次调用其中的 handler</p>
</li>
</ul>
</li>
<li><p>handler 分 Inbound 和 Outbound 两类</p>
<ul>
<li>Inbound 入站</li>
<li>Outbound 出站</li>
</ul>
</li>
<li><p>eventLoop 可以理解为处理数据的工人</p>
<ul>
<li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就会将其与channel进行绑定，以后该 channel 中的 io 操作都由该 eventLoop 负责</li>
<li>eventLoop 既可以执行 io 操作，也可以进行任务处理，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>
<li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li>
</ul>
</li>
</ul>
<h3 id="4-组件"><a href="#4-组件" class="headerlink" title="4. 组件"></a>4. 组件</h3><h4 id="4-1-EventLoop"><a href="#4-1-EventLoop" class="headerlink" title="4.1 EventLoop"></a>4.1 EventLoop</h4><ul>
<li><p>事件循环对象 EventLoop</p>
<ul>
<li><p>EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p>
</li>
<li><p>它的继承关系如下</p>
<ul>
<li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>继承自 netty 自己的 OrderedEventExecutor<ul>
<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>事件循环组 EventLoopGroup</p>
<ul>
<li><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>
</li>
<li><p>继承自 netty 自己的 EventExecutorGroup</p>
<ul>
<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>
<li>另有 next 方法获取集合中下一个 EventLoop</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-1-1-处理普通、定时任务"><a href="#4-1-1-处理普通、定时任务" class="headerlink" title="4.1.1 处理普通、定时任务"></a>4.1.1 处理普通、定时任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEventLoop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 通过next方法可以获得下一个 EventLoop</span></span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过EventLoop执行普通任务</span></span><br><span class="line">        group.next().execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过EventLoop执行定时任务</span></span><br><span class="line">        group.next().scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; hello2&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 优雅地关闭</span></span><br><span class="line">        group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭 EventLoopGroup</p>
<ul>
<li>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</li>
</ul>
<h5 id="4-1-2-处理IO任务"><a href="#4-1-2-处理IO任务" class="headerlink" title="4.1.2 处理IO任务"></a>4.1.2 处理IO任务</h5><p>服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>))</span><br><span class="line">                .sync()</span><br><span class="line">                .channel();</span><br><span class="line">        System.out.println(channel);</span><br><span class="line">        <span class="comment">// 此处打断点调试，调用 channel.writeAndFlush(...);</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-3-分工细化"><a href="#4-1-3-分工细化" class="headerlink" title="4.1.3 分工细化"></a>4.1.3 分工细化</h5><ul>
<li>初次细化：Bootstrap的group()方法可以传入两个EventLoopGroup参数，分别负责处理不同的事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">            	<span class="comment">// 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">            </span><br><span class="line">				...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个EventLoop可以负责多个Channel，且EventLoop一旦与Channel绑定，则一直负责处理该Channel中的事件</p>
<ul>
<li>二次细化：增加自定义EventLoopGroup</li>
</ul>
<p>当有的任务需要较长的时间处理时，可以使用非NioEventLoopGroup，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 增加自定义的非NioEventLoopGroup</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">// 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理</span></span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="string">&quot;nioHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                <span class="comment">// 调用下一个handler</span></span><br><span class="line">                                ctx.fireChannelRead(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        <span class="comment">// 该handler绑定自定义的Group</span></span><br><span class="line">                        .addLast(group, <span class="string">&quot;myHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现原理<ul>
<li>如果两个 handler 绑定的是同一个EventLoopGroup，那么就直接调用</li>
<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="comment">// 获得下一个EventLoop, excutor 即为 EventLoopGroup</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果下一个EventLoop 在当前的 EventLoopGroup中</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 使用当前 EventLoopGroup 中的 EventLoop 来处理任务</span></span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-Channel"><a href="#4-2-Channel" class="headerlink" title="4.2 Channel"></a>4.2 Channel</h4><p>Channel 的常用方法</p>
<ul>
<li>close() 可以用来关闭Channel</li>
<li>closeFuture() 用来处理 Channel 的关闭<ul>
<li>sync 方法作用是同步等待 Channel 关闭，调用线程等待</li>
<li>addListener 方法是异步等待 Channel 关闭，非调用线程</li>
</ul>
</li>
<li>pipeline() 方法用于添加处理器</li>
<li>write() 方法将数据写入<ul>
<li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li>
<li>只有当缓冲满了或者调用了flush()方法后，才会将数据通过 Channel 发送出去，或者缓冲区数据达到可发送界限</li>
</ul>
</li>
<li>writeAndFlush() 方法将数据写入并立即发送（刷出），相当于write() + flush()</li>
</ul>
<h5 id="4-2-1-sync方法"><a href="#4-2-1-sync方法" class="headerlink" title="4.2.1 sync方法"></a>4.2.1 sync方法</h5><p>建立连接(connect)的过程是异步非阻塞的，若不通过<code>sync()</code>方法阻塞主线程(调用线程)，等待连接真正建立，这时通过 channelFuture.channel() 拿到的 Channel 对象，还未真正与服务器建立好连接，也就没法将信息正确的传输给服务器端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span></span><br><span class="line">            	<span class="comment">// NIO线程：NioEventLoop 中的线程</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 该方法用于等待连接真正建立</span></span><br><span class="line">        channelFuture.sync();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取客户端-服务器之间的Channel对象</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">        channel.writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<ul>
<li>所以需要通过channelFuture.sync()方法，阻塞主线程，同步处理结果，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程都是主线程</li>
<li>用于异步获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO(eventLoop) 线程（去执行connect操作的线程），使用addListener方法编写回调函数</li>
</ul>
<h5 id="4-2-2-关闭Channel"><a href="#4-2-2-关闭Channel" class="headerlink" title="4.2.2 关闭Channel"></a>4.2.2 关闭Channel</h5><p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个异步方法。真正的关闭操作并不是在调用该方法的线程中执行的，而是在NIO线程中执行真正的关闭操作</p>
<p>如果我们想在channel真正关闭以后，执行一些额外的操作，可以选择以下两种方法来实现</p>
<ul>
<li>通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</li>
<li>调用closeFuture.addListener方法，添加close的后续操作</li>
</ul>
<h4 id="4-3-Future与Promise"><a href="#4-3-Future与Promise" class="headerlink" title="4.3 Future与Promise"></a>4.3 Future与Promise</h4><p>概念</p>
<ul>
<li><p>netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口</p>
</li>
<li><p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>
<ul>
<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>
<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li>
<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li>
</ul>
</li>
</ul>
<ol>
<li>JDK Future</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkFuture</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;JdkFuture&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>,<span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得Future对象</span></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过阻塞的方式，获得运行结果</span></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Netty Future</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyFuture</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 EventLoop 对象</span></span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> group.next();</span><br><span class="line">        Future&lt;Integer&gt; future = eventLoop.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程中获取结果</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取结果&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;getNow &quot;</span> + future.getNow());</span><br><span class="line">        System.out.println(<span class="string">&quot;get &quot;</span> + future.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// NIO线程中异步获取结果</span></span><br><span class="line">        future.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Integer&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取结果&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;getNow &quot;</span> + future.getNow());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Netty Promise</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyPromise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建EventLoop</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">next</span> <span class="operator">=</span> eventExecutors.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Promise(), 需要将eventLoop作为参数进行传递</span></span><br><span class="line">        DefaultPromise&lt;Integer&gt; integerDefaultPromise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(next);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;开始计算&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;开始计算，异常场景&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                integerDefaultPromise.setSuccess(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                integerDefaultPromise.setFailure(e);</span><br><span class="line">		<span class="comment">//     integerDefaultPromise.cancel(false);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        log.info(<span class="string">&quot;main thread get result&quot;</span>);</span><br><span class="line">        integerDefaultPromise.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Integer&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.info(<span class="string">&quot;promise 的result is Fail or success：&#123;&#125;&quot;</span>, integerDefaultPromise.isSuccess());</span><br><span class="line">                <span class="keyword">if</span> (!integerDefaultPromise.isSuccess()) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;error info&quot;</span>, integerDefaultPromise.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 使用promise也可是使用，getNow()等方法，获取同步结果，以及添加使用addListener等方法</span></span><br><span class="line">        <span class="comment">// log.info(&quot;获取结果: &#123;&#125;&quot;, integerDefaultPromise.get());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-ByteBuf"><a href="#4-4-ByteBuf" class="headerlink" title="4.4 ByteBuf"></a>4.4 ByteBuf</h4><ul>
<li><p>创建</p>
<ul>
<li>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的，默认使用直接内存作为ByteBuf，容量为256个字节，可以指定初始容量的大小</li>
<li>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</li>
</ul>
</li>
<li><p>直接内存与堆内存</p>
<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>
<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>
<li>堆内存使用的就是JVM中的堆，直接内存不在堆中</li>
</ul>
</li>
<li><p>池化与非池化</p>
<ul>
<li>池化的最大意义在于可以重用 ByteBuf，优点有<ul>
<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>
<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率高并发时，池化功能更节约内存，减少内存溢出的可能</li>
</ul>
</li>
</ul>
</li>
<li><p>组成</p>
<ul>
<li>最大容量与当前容量<ul>
<li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li>
<li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，达到一个按需索取，若超出最大容量，会抛出java.lang.IndexOutOfBoundsException异常</li>
</ul>
</li>
<li>读写操作不同于ByteBuffer只用position进行控制，ByteBuf分别由读指针和写指针两个指针控制。进行读写操作时，无需进行模式的切换，初始状态，读写指针都是在0位置<ul>
<li>读指针前的部分被称为废弃部分，是已经读过的内容</li>
<li>读指针与写指针之间的空间称为可读部分</li>
<li>写指针与当前容量之间的空间称为可写部分</li>
</ul>
</li>
</ul>
</li>
<li><p>写入</p>
<ul>
<li>一些write开头的API</li>
</ul>
</li>
<li><p>扩容</p>
<ul>
<li>如果写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容<ul>
<li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节，如果写入后的大小为17个字节，则扩容之后的 capacity 是32字节</li>
</ul>
</li>
<li>如果写入后数据大小超过 512 字节，则选择下一个 2^n<ul>
<li>例如写入后大小为 513 字节，则扩容后 capacity 是 2^10&#x3D;1024 字节（2^9&#x3D;512 已经不够了）</li>
</ul>
</li>
<li>扩容不能超过 maxCapacity，否则会抛出java.lang.IndexOutOfBoundsException异常</li>
</ul>
</li>
<li><p>读取</p>
<ul>
<li>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</li>
<li>如果需要重复读取，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</li>
</ul>
</li>
<li><p>释放</p>
<ul>
<li>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。<ul>
<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>
<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>
<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
</li>
<li>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 **ReferenceCounted **接口<ul>
<li>每个 ByteBuf 对象的初始计数为 1</li>
<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>
<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>
<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>
</ul>
</li>
<li>释放规则</li>
<li>因为 pipeline 的存在，存在多个handler，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个ByteBuf 已完成了它的使命，那么便无须再传递）基本规则是，谁是最后使用者，谁负责 release</li>
</ul>
</li>
<li><p>切片</p>
<ul>
<li>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</li>
<li>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</li>
<li>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</li>
</ul>
</li>
<li><p>组合</p>
<ul>
<li>使用CompositeByteBuf可将小的byteBuf组合成大的bytebuf，且不发生数据的复制拷贝</li>
</ul>
</li>
<li><p>优势</p>
<ul>
<li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>
<li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li>
<li>可以自动扩容</li>
<li>支持链式调用，使用更流畅</li>
<li>很多地方体现零拷贝，例如<ul>
<li>slice、duplicate、CompositeByteBuf</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第三章-Netty进阶"><a href="#第三章-Netty进阶" class="headerlink" title="第三章 Netty进阶"></a>第三章 Netty进阶</h2><h3 id="1-粘包与半包"><a href="#1-粘包与半包" class="headerlink" title="1.粘包与半包"></a>1.粘包与半包</h3><p>粘包</p>
<ul>
<li>现象<ul>
<li>发送 abc def，接收 abcdef</li>
</ul>
</li>
<li>原因<ul>
<li>应用层<ul>
<li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li>
</ul>
</li>
<li>传输层-网络层<ul>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包<ul>
<li>是一种优化手段，尽可能多的发送数据，而不是存在数据就发送，特别是数据和报文头大小相差较大</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>半包</p>
<ul>
<li>现象<ul>
<li>发送 abcdef，接收 abc def</li>
</ul>
</li>
<li>原因<ul>
<li>应用层<ul>
<li>接收方 ByteBuf 小于实际发送数据量</li>
</ul>
</li>
<li>传输层-网络层<ul>
<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>
</ul>
</li>
<li>数据链路层<ul>
<li>MSS 限制：当发送的数据超过 MSS 限制（MTU）后，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>本质</p>
<ul>
<li>发生粘包与半包现象的本质是因为 TCP 是流式协议，消息无边界</li>
</ul>
<h4 id="1-1-解决方案"><a href="#1-1-解决方案" class="headerlink" title="1.1 解决方案"></a>1.1 解决方案</h4><h5 id="1-1-1-短链接"><a href="#1-1-1-短链接" class="headerlink" title="1.1.1 短链接"></a>1.1.1 短链接</h5><p>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以短链接无法解决半包现象</p>
<h5 id="1-1-2-定长解码器"><a href="#1-1-2-定长解码器" class="headerlink" title="1.1.2 定长解码器"></a>1.1.2 定长解码器</h5><p>客户端于服务器约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度。若发送数据长度不足则需要补齐至该长度</p>
<p>服务器接收数据时，将接收到的数据按照约定的最大长度进行拆分，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。服务端需要用到FixedLengthFrameDecoder对数据进行定长解码。</p>
<h5 id="1-1-3-行解码器"><a href="#1-1-3-行解码器" class="headerlink" title="1.1.3 行解码器"></a>1.1.3 行解码器</h5><p>行解码器的是通过分隔符对数据进行拆分来解决粘包半包问题的</p>
<p>可以通过LineBasedFrameDecoder(int maxLength)来拆分以换行符(\n)为分隔符的数据，也可以通过DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf… delimiters)来指定通过什么分隔符来拆分数据（可以传入多个分隔符）</p>
<p>两种解码器都需要传入数据的最大长度，若超出最大长度，会抛出TooLongFrameException异常</p>
<p>以换行符 \n 为分隔符</p>
<h5 id="1-1-4-长度字段解码器"><a href="#1-1-4-长度字段解码器" class="headerlink" title="1.1.4 长度字段解码器"></a>1.1.4 长度字段解码器</h5><p>在传送数据时可以在数据中添加一个用于表示有用数据长度的字段，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p>
<p>LengthFieldBasedFrameDecoder解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LengthFieldBasedFrameDecoder</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxFrameLength, 		// 解析数据的最大长度</span></span><br><span class="line"><span class="params">    <span class="type">int</span> lengthFieldOffset, 		// 数据长度标识的起始偏移量</span></span><br><span class="line"><span class="params">    <span class="type">int</span> lengthFieldLength,		// 数据长度标识所占的字节数</span></span><br><span class="line"><span class="params">    <span class="type">int</span> lengthAdjustment,		// 有效数据与数据长度标识结束位置之间的偏移量</span></span><br><span class="line"><span class="params">    <span class="type">int</span> initialBytesToStrip)</span>	<span class="comment">// 截取的报文数据起始偏移量，从头开始剥离几个字节</span></span><br></pre></td></tr></table></figure>

<p>参数解析</p>
<ul>
<li>maxFrameLength 数据最大长度<ul>
<li>表示数据的最大长度（包括附加信息、长度标识等内容）</li>
</ul>
</li>
<li>lengthFieldOffset 数据长度标识的起始偏移量<ul>
<li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li>
</ul>
</li>
<li>lengthFieldLength 数据长度标识所占字节数（用于指明有用数据的长度）<ul>
<li>数据中用于表示有用数据长度的标识所占的字节数</li>
</ul>
</li>
<li>lengthAdjustment 长度表示与有用数据的偏移量<ul>
<li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li>
</ul>
</li>
<li>initialBytesToStrip 数据读取起点<ul>
<li>读取起点，不读取 0 ~ initialBytesToStrip 之间的数据</li>
</ul>
</li>
</ul>
<h3 id="2-协议设计与解析"><a href="#2-协议设计与解析" class="headerlink" title="2. 协议设计与解析"></a>2. 协议设计与解析</h3><p>协议的作用</p>
<p>TCP&#x2F;IP 中消息传输基于流的方式，没有边界。协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</p>
<h4 id="2-1-自定义协议"><a href="#2-1-自定义协议" class="headerlink" title="2.1 自定义协议"></a>2.1 自定义协议</h4><p>组成要素</p>
<ul>
<li><p>魔数：用来在第一时间判定接收的数据是否为无效数据包</p>
</li>
<li><p>版本号：可以支持协议的升级</p>
</li>
<li><p>序列化算法：消息正文到底采用哪种序列化反序列化方式</p>
<ul>
<li>如：json、protobuf、hessian、jdk</li>
</ul>
</li>
<li><p>指令类型：是登录、注册、单聊、群聊… 跟业务相关</p>
</li>
<li><p>请求序号：为了双工通信，提供异步能力</p>
</li>
<li><p>正文长度</p>
</li>
<li><p>消息正文</p>
</li>
</ul>
<p>编码解码器例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodec</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 设置四字节 魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;N&#x27;</span>&#125;);</span><br><span class="line">        <span class="comment">// 设置一字节 版本号</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置一字节 序列化算法，此处使用jdk的序列化算法 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置一字节 指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 设置四字节 请求序号,目的提供双工通信，提供异步能力</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 附加信息最好是2的n次方位，4+1+1+1+4+4(内容长度字段)=15,最近的是16，因此添加一字节，补齐16</span></span><br><span class="line">        out.writeByte(<span class="number">0x13</span>);</span><br><span class="line">        <span class="comment">// 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(outputStream);</span><br><span class="line">        objectOutputStream.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = outputStream.toByteArray();</span><br><span class="line">        <span class="comment">// 设置四字节 内容长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 根据加密进行获取相关的值</span></span><br><span class="line">        <span class="comment">// 获取魔数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="comment">// 获取版本号</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">// 获取序列化类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">// 获取指令类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">// 获取请求序号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="comment">// 获取填充位</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">fill</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">// 获取字段内容长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="comment">// 获取传输的内容</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) objectInputStream.readObject();</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, fill, length);</span><br><span class="line">        log.info(<span class="string">&quot;request message=&#123;&#125;&quot;</span>, message);</span><br><span class="line">        <span class="comment">// 将信息放入list，传递给下一个handler</span></span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第四章-Netty优化"><a href="#第四章-Netty优化" class="headerlink" title="第四章 Netty优化"></a>第四章 Netty优化</h2>
  </article>
  <!-- tag -->
  <div class="mt-12 pt-6 border-t border-gray-200">
    
      
        <span class="bg-gray-100 dark:bg-gray-700 px-2 py-1 m-1 text-sm rounded-md transition-colors hover:bg-gray-200">
          <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
        </span>
      
    
  </div>
  <!-- prev and next -->
  <div class="flex justify-between mt-12 pt-6 border-t border-gray-200">
    <div>
      
        <a href="/2025/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          <iconify-icon width="20" icon="ri:arrow-left-s-line" data-inline="false"></iconify-icon>
          设计模式
        </a>
      
    </div>
    <div>
      
        <a href="/2024/12/06/%E7%BD%91%E7%AB%99%E5%9C%B0%E5%9D%80/" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          网站集合
          <iconify-icon width="20" icon="ri:arrow-right-s-line" data-inline="false"></iconify-icon>
        </a>
      
    </div>
  </div>
  <!-- comment -->
  <div class="article-comments mt-12">
    

  </div>
</section>
<!-- js inspect -->

<script src="/lib/clipboard.min.js"></script>


<script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  $(document).ready(() => {
    const maraidConfig = {
      theme: "default",
      logLevel: 3,
      flowchart: { curve: "linear" },
      gantt: { axisFormat: "%m/%d/%Y" },
      sequence: { actorMargin: 50 },
    };
    mermaid.initialize(maraidConfig);
  });
</script>



<script src="/lib/fancybox/fancybox.umd.min.js"></script>

<script>
  $(document).ready(() => {
    $('.post-content').each(function(i){
      $(this).find('img').each(function(){
        if ($(this).parent().hasClass('fancybox') || $(this).parent().is('a')) return;
        var alt = this.alt;
        if (alt) $(this).after('<span class="fancybox-alt">' + alt + '</span>');
        $(this).wrap('<a class="fancybox-img" href="' + this.src + '" data-fancybox=\"gallery\" data-caption="' + alt + '"></a>')
      });
      $(this).find('.fancybox').each(function(){
        $(this).attr('rel', 'article' + i);
      });
    });

    Fancybox.bind('[data-fancybox="gallery"]', {
        // options
    })
  })
</script>

<!-- tocbot begin -->

<script src="/lib/tocbot/tocbot.min.js"></script>

<script>
  $(document).ready(() => {
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '.post-toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '.post-content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h1, h2, h3',
        // For headings inside relative or absolute positioned containers within content.
        hasInnerContainers: true,
    });
  })
</script>
<!-- tocbot end -->


  </main>
  <footer class="flex flex-col h-40 items-center justify-center text-gray-400 text-sm">
  <!-- busuanzi -->
  
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- Busuanzi Analytics -->
<div class="flex items-center gap-2">
  <span>Visitors</span>
  <span id="busuanzi_value_site_uv"></span>
  <span>Page Views</span>
  <span id="busuanzi_value_site_pv"></span>
</div>
<!-- End Busuanzi Analytics -->


  <!-- copyright -->
  <div class="flex items-center gap-2">
    <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color: inherit;">CC BY-NC-SA 4.0</a>
    <span>© 2022</span>
    <iconify-icon width="18" icon="emojione-monotone:maple-leaf" ></iconify-icon>
    <a href="https://github.com/xbmlz" target="_blank" rel="noopener noreferrer">xbmlz</a>
  </div>
  <!-- powered by -->
  <div class="flex items-center gap-2">
    <span>Powered by</span>
    <a href="https://hexo.io/" target="_blank" rel="noopener noreferrer">Hexo</a>
    <span>&</span>
    <a href="https://github.com/xbmlz/hexo-theme-maple" target="_blank" rel="noopener noreferrer">Maple</a>
  </div>

</footer>

  <div class="back-to-top box-border fixed right-6 z-1024 -bottom-20 rounded py-1 px-1 bg-slate-900 opacity-60 text-white cursor-pointer text-center dark:bg-slate-600">
    <span class="flex justify-center items-center text-sm">
      <iconify-icon width="18" icon="ion:arrow-up-c" id="go-top"></iconify-icon>
      <span id="scrollpercent"><span>0</span> %</span>
    </span>
  </div>
  
<script src="/js/main.js"></script>


  <script>
    $(document).ready(function () {
      const mapleCount = "10";
      const speed = "0.5";
      const mapleEl = document.getElementById("maple");
      const maples = Array.from({ length: mapleCount }).map(() => {
        const maple = document.createElement("div");
        const scale = Math.random() * 0.5 + 0.5;
        const offset = Math.random() * 2 - 1;
        const x = Math.random() * mapleEl.clientWidth;
        const y = -Math.random() * mapleEl.clientHeight;
        const duration = 10 / speed;
        const delay = -duration;
        maple.className = "maple";
        maple.style.width = `${24 * scale}px`;
        maple.style.height = `${24 * scale}px`;
        maple.style.left = `${x}px`;
        maple.style.top = `${y}px`;
        maple.style.setProperty("--maple-fall-offset", offset);
        maple.style.setProperty("--maple-fall-height", `${Math.abs(y) + mapleEl.clientHeight}px`);
        maple.style.animation = `fall ${duration}s linear infinite`;
        maple.style.animationDelay = `${delay}s`;
        mapleEl.appendChild(maple)
        return maple
      })
    });
  </script>
  


  <div class="fixed top-0 bottom-0 left-0 right-0 pointer-events-none print:hidden" id="maple"></div>
</body>

</html>
