<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">




<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

  <meta name="author" content="jiahe">


  <meta name="subtitle" content="待到山花烂漫时...">


  <meta name="description" content="一个在github上搭建的个人博客">



<title>RabbitMQ | 个人学习博客</title>



<link rel="icon" href="/favicon.png">



<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/nprogress/nprogress.css">



<script src="/lib/jquery.min.js"></script>


<script src="/lib/iconify-icon.min.js"></script>


<script src="https://cdn.tailwindcss.com?plugins=typography"></script>
<script>
  tailwind.config = {
    darkMode: "class",
  };
</script>


<script src="/lib/nprogress/nprogress.js"></script>

<script>
  $(document).ready(() => {
    NProgress.configure({
      showSpinner: false,
    });
    NProgress.start();
    $("#nprogress .bar").css({
      background: "#de7441",
    });
    $("#nprogress .peg").css({
      "box-shadow": "0 0 2px #de7441, 0 0 4px #de7441",
    });
    $("#nprogress .spinner-icon").css({
      "border-top-color": "#de7441",
      "border-left-color": "#de7441",
    });
    setTimeout(function () {
      NProgress.done();
      $(".fade").removeClass("out");
    }, 800);
  });
</script>

<script>
  (function () {
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const setting = localStorage.getItem("hexo-color-scheme") || "auto";
    if (setting === "dark" || (prefersDark && setting !== "light"))
      document.documentElement.classList.toggle("dark", true);
    let isDark = document.documentElement.classList.contains("dark");
  })();

  $(document).ready(function () {
    // init icon
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const isDark = document.documentElement.classList.contains("dark");
    $("#theme-icon").attr("icon", isDark ? "ri:moon-line" : "ri:sun-line");

    function toggleGiscusTheme() {
      const isDark = document.documentElement.classList.contains("dark");
      const giscusFrame = document.querySelector("iframe.giscus-frame");
      if (giscusFrame) {
        giscusFrame.contentWindow.postMessage(
          {
            giscus: {
              setConfig: {
                theme: isDark ? "dark" : "light",
              },
            },
          },
          "https://giscus.app"
        );
      }
    }


    // toggle dark mode
    function toggleDark() {
      let isDark = document.documentElement.classList.contains("dark");
      const setting = localStorage.getItem("hexo-color-scheme") || "auto";
      isDark = !isDark;
      document.documentElement.classList.toggle("dark", isDark);
      $("#theme-icon").attr("icon", isDark ? "ri:moon-line" : "ri:sun-line");
      if (prefersDark === isDark) {
        localStorage.setItem("hexo-color-scheme", "auto");
      } else {
        localStorage.setItem("hexo-color-scheme", isDark ? "dark" : "light");
      }
      toggleGiscusTheme();
    }
    $("#toggle-dark").click(toggleDark);

    // listen dark mode change
    window
      .matchMedia("(prefers-color-scheme: dark)")
      .addEventListener("change", (e) => {
        const setting = localStorage.getItem("hexo-color-scheme") || "auto";
        if (setting === "auto") {
          document.documentElement.classList.toggle("dark", e.matches);
          $("#theme-icon").attr(
            "icon",
            e.matches ? "ri:moon-line" : "ri:sun-line"
          );
          toggleGiscusTheme();
        }
      });
  });
</script>




<meta name="generator" content="Hexo 7.2.0"></head>
<body class="font-sans bg-white dark:bg-zinc-900 text-gray-700 dark:text-gray-200 relative">
  <header class="fixed w-full px-5 py-1 z-10 backdrop-blur-xl backdrop-saturate-150 border-b border-black/5">
  <div class="max-auto">
    <nav class="flex items-center text-base">
      <a href="/" class="group">
        <h2 class="font-medium tracking-tighterp text-l p-2">
          <img class="w-5 mr-2 inline-block transition-transform group-hover:rotate-[30deg]" id="logo" src="/images/logo.svg" alt="个人学习博客" />
          个人学习博客
        </h2>
      </a>
      <div id="header-title" class="opacity-0 md:ml-2 md:mt-[0.1rem] text-xs font-medium whitespace-nowrap overflow-hidden overflow-ellipsis">
        RabbitMQ
      </div>
      <div class="flex-1"></div>
      <div class="flex items-center gap-3">
        
          <a class="hidden sm:flex" href="/archives">Posts</a>
        
        
          
            <a class="w-5 h-5 hidden sm:flex" title="Github" target="_blank" rel="noopener" href="https://github.com/qjh04">
              <iconify-icon width="20" icon="ri:github-line"></iconify-icon>
            </a>
          
        
        <a class="w-5 h-5 hidden sm:flex" title="Github" href="rss2.xml">
          <iconify-icon width="20" icon="ri:rss-line"></iconify-icon>
        </a>
        <a class="w-5 h-5" title="toggle theme" id="toggle-dark">
          <iconify-icon width="20" icon="" id="theme-icon"></iconify-icon>
        </a>
      </div>
      <div class="flex items-center justify-center gap-3 ml-3 sm:hidden">
        <span class="w-5 h-5" aria-hidden="true" role="img" id="open-menu">
          <iconify-icon width="20" icon="carbon:menu" ></iconify-icon>
        </span>
        <span class="w-5 h-5 hidden" aria-hidden="true" role="img" id="close-menu">
          <iconify-icon  width="20" icon="carbon:close" ></iconify-icon>
        </span>
      </div>
    </nav>
  </div>
</header>
<div id="menu-panel" class="h-0 overflow-hidden sm:hidden fixed left-0 right-0 top-12 bottom-0 z-10">
  <div id="menu-content" class="relative z-20 bg-white/80 px-6 sm:px-8 py-2 backdrop-blur-xl -translate-y-full transition-transform duration-300">
    <ul class="nav flex flex-col sm:flex-row text-sm font-medium">
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/archives" class="flex h-12 sm:h-auto items-center">Posts</a>
        </li>
      
    </ul>
  </div>
  <div class="mask bg-black/20 absolute inset-0"></div>
</div>

  <main class="pt-14">
    <!-- css -->

<link rel="stylesheet" href="/lib/fancybox/fancybox.min.css">


<link rel="stylesheet" href="/lib/tocbot/tocbot.min.css">

<!-- toc -->

  <!-- tocbot -->
<nav class="post-toc toc text-sm w-48 relative top-32 right-0 opacity-70 hidden lg:block" style="position: fixed !important;"></nav>


<section class="px-6 max-w-prose mx-auto md:px-0">
  <!-- header -->
  <header class="overflow-hidden pt-6 pb-6 md:pt-12">
    <div class="pt-4 md:pt-6">
      <h1 id="article-title" class="text-[2rem] font-bold leading-snug mb-4 md:mb-6 md:text-[2.6rem]">
        RabbitMQ
      </h1>
      <div>
        <section class="flex items-center gap-3 text-sm">
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="carbon-calendar" ></iconify-icon>
            <time>2024-07-30</time>
          </span>
          <span class="text-gray-400">·</span>
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="ic:round-access-alarm" ></iconify-icon>
            <span>13 min</span>
          </span>
          <span class="text-gray-400">·</span>
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="icon-park-outline:font-search" ></iconify-icon>
            <span>3.4k words</span>
          </span>
                  
        </section>
      </div>
    </div>
  </header>
  <!-- content -->
  <article class="post-content prose m-auto slide-enter-content dark:prose-invert">
    <h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p><a target="_blank" rel="noopener" href="https://b11et3un53m.feishu.cn/wiki/OQH4weMbcimUSLkIzD6cCpN0nvc">‬﻿﻿‍‌﻿‬‬⁠‍﻿‌⁠‌﻿⁠‬⁠﻿‌‌﻿‌﻿﻿‍⁠‌‍day06-MQ基础 - 飞书云文档 (feishu.cn)</a></p>
<p>RabbitMQ的整体架构及核心概念:</p>
<ul>
<li><p>virtual-host:虚拟主机,起到数据隔离的作用</p>
</li>
<li><p>publisher:消息发送者</p>
</li>
<li><p>consumer:消息的消费者</p>
</li>
<li><p>queue:队列,存储消息</p>
</li>
<li><p>exchange: 交换机,负责路由消息</p>
</li>
</ul>
<h2 id="第一章-Java客户端操作"><a href="#第一章-Java客户端操作" class="headerlink" title="第一章 Java客户端操作"></a>第一章 Java客户端操作</h2><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>AMQP：一种通信协议，用于应用程序之间传递业务消息。<br>SpringAMQP：是基于AMQP的一套规范API，包含两部分。一部分是spring-amqp是基础抽象，spring-rabbit是底层的默认实现</p>
<p>步骤：</p>
<ul>
<li>先引入依赖：spring-boot-starter-amqp</li>
<li>配置RabbitMQ配置信息，ip地址、虚拟主机、密码、账户等</li>
<li>准备两个微服务：生产者和消费者<ul>
<li>用rabbitTemplate工具类收发消息</li>
<li>定义一个专门接收消息的类，注册成bean，然后在类里面的方法上加@RabbitListener（queues&#x3D;queueName）注解，方法参数用来接收消息。</li>
</ul>
</li>
</ul>
<h3 id="WorkQueues模式"><a href="#WorkQueues模式" class="headerlink" title="WorkQueues模式"></a>WorkQueues模式</h3><p>实现一个队列，绑定多个消费者</p>
<p>生产者生产出多个消息时，默认轮询给消费者，可以在yml文件中配置prefetch： 1，每次抓取一个完成后才能继续处理。当生产者太快，单个消费者已经处理不过来的时候，消息就在队列里积累，越积越多，产生消息堆积问题。解决这个问题就要多加消费者，但是每个消费者消费能力不一样，所以要设置这个。</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机分三种：Fanout  广播、Direct  直接类似点对点、Topic  话题类似组播</p>
<ul>
<li>Fanout交换机，将接收到的消息广播分发到每一个绑定的消息队列上</li>
<li>Direct交换机，会将接收的消息按照路由规则分发到指定消息队列上<ul>
<li>BindingKey，当消息队列与交换机绑定时设置的 </li>
<li>RoutingKey，交换机接收消息转发时目的key</li>
</ul>
</li>
<li>Topic交换机，也有BindingKey、RoutingKey，区别在于BindingKey可以有通配符（#0个单词，*多个单词），RoutingKey由多个单词组成用点号 ‘.’ 分割。会将接收到的消息按照匹配规则分发给指定的消息队列上</li>
</ul>
<h3 id="声明队列交换机"><a href="#声明队列交换机" class="headerlink" title="声明队列交换机"></a>声明队列交换机</h3><p>用Java代码声明队列交换机，SpringAMQP提供了几个类，用来声明队列、交换机及其绑定关系:</p>
<ul>
<li><p>Queue:用于声明队列,可以用工厂类QueueBuilder构建</p>
</li>
<li><p>Exchange:用于声明交换机,可以用工厂类ExchangeBuilder构建</p>
</li>
<li><p>Binding:用于声明队列和交换机的绑定关系,可以用工厂类BindingBuilder构建</p>
</li>
</ul>
<p>一般在消费者处声明，可以建个配置类，将以上通过方法都注册成bean。但是这种方式也非常负责，建议使用注解方式声明。举例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">	value = @Queue(name = &quot;direct.queue1&quot;, durable = &quot;true&quot;),// durable用于持久化</span></span><br><span class="line"><span class="meta">	exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">	key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;消费者1接收到Direct消息:【&quot;</span>+msg+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>如果发送对象的话，用默认JDK消息转换器，会把对象变得特别臃肿，可读性差，安全性降低。所以采用JSON序列化，引入依赖Jackson-databind，在配置类中编写一个bean类型为MessageConverter，返回Jackson依赖中的转换器。 </p>
<h2 id="第二章-可靠性问题"><a href="#第二章-可靠性问题" class="headerlink" title="第二章 可靠性问题"></a>第二章 可靠性问题</h2><h3 id="生产者可靠性"><a href="#生产者可靠性" class="headerlink" title="生产者可靠性"></a>生产者可靠性</h3><h4 id="生产者重连"><a href="#生产者重连" class="headerlink" title="生产者重连"></a>生产者重连</h4><p>有的时候由于网络波动,可能会出现客户端连接MQ失败的情况。通过配置我们可以开启连接失败后的重连机制:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">conpection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">		<span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">		<span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">		<span class="string">multiplier:1</span> <span class="comment"># 失败后下次的等待时长倍数,下次等待时长=initial-interval * multiplier</span></span><br><span class="line">		<span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure>

<p>这个机制是阻塞式重试，会影响服务性能，对于服务性能有要求，关闭重试机制。如果一定使用，一定要合理配置各个参数</p>
<h4 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h4><p>RabbitMQ了Publisher Confirm和Publisher Return两种确认机制。开启确机制认后,在MQ成功收到消息后会返回确<br>认消息给生产者。返回的结果有以下几种情况:</p>
<ul>
<li><p>消息投递到了MQ,但是路由失败。此时会通过PublisherReturn返回路由异常原因,然后返回ACK,告知投递成功</p>
</li>
<li><p>临时消息投递到了MQ,并且入队成功,返回ACK,告知投递成功</p>
</li>
<li><p>持久消息投递到了MQ,并且入队完成持久化,返回ACK,告知投递成功</p>
</li>
<li><p>其它情况都会返回NACK,告知投递失败</p>
</li>
</ul>
<p>有返回值，就需要编码解决返回值问题</p>
<p>第一步：配置yml文件</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">	<span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制,并设置confirm类型</span></span><br><span class="line">	<span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制 测试开启 一般不开</span></span><br></pre></td></tr></table></figure>

<p>type有三种选择方式</p>
<ul>
<li><p>none:关闭confirm机制</p>
</li>
<li><p>simple:同步阻塞等待MQ的回执消息</p>
</li>
<li><p>correlated:MQ异步回调方式返回回执消息</p>
</li>
</ul>
<p>第二步：处理返回值，编写回调函数</p>
<p>1、每一个RabbitTemplate只能有一个ReturnCallBack，因此需要再项目启动时配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span> <span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取RabbitTemplate</span></span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        <span class="comment">// 设置ReturnCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(</span><br><span class="line">            (message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败,应答码&#123;&#125;,原因&#123;&#125;,交换机&#123;&#125;,路由键[&#125;,消息&#123;&#125;”,</span></span><br><span class="line"><span class="string">                     replyCode, replyText, exchange, routingKey, message.toString());</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>2、confirm机制的Java代码，因为每次发消息都需要判断，所以每次都需要加上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 1.创建CorrelationData</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">    <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.Future发生异常时的处理逻辑,基本不会触发</span></span><br><span class="line">            log.error (<span class="string">&quot;handle message ack fail&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSucces</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">             <span class="comment">// 2.2.Future接收到回执的处理逻辑,参数中的result就是回执内容</span></span><br><span class="line">             <span class="keyword">if</span>(result.isAck())&#123;<span class="comment">// result.isAck(),boolean类型,true代表ack回执,false 代表 nack回执</span></span><br><span class="line">                  log.debug(“发送消息成功,收到 ack!<span class="string">&quot;);</span></span><br><span class="line"><span class="string">             &#125;else&#123;//result.getReason(),String类型,返回nack时的异常描述</span></span><br><span class="line"><span class="string">                  log.error(“发送消息失败,收到 nack,reason:&#123;&#125;&quot;</span>,result.getReason());</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);   </span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;red1&quot;</span>, <span class="string">&quot;hello&quot;</span>,cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MQ可靠性"><a href="#MQ可靠性" class="headerlink" title="MQ可靠性"></a>MQ可靠性</h3><p>在默认情况下,RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。这样会导致两个问题:</p>
<ul>
<li>一旦MQ宕机,内存中的消息会丢失</li>
<li>内存空间有限,当消费者故障或处理过慢时,会导致消息积压,引发MQ阻塞</li>
</ul>
<h4 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h4><p>一般包括三个方面：</p>
<ul>
<li>队列持久化</li>
<li>交换机持久化</li>
<li>消息持久化</li>
</ul>
<p>前两个，spring中默认开启，最后一个，在发送时消息体可以设置。</p>
<h4 id="LazyQueue"><a href="#LazyQueue" class="headerlink" title="LazyQueue"></a>LazyQueue</h4><p>从RabbitMQ的3.6.0版本开始,就增加了Lazy Queue的概念,也就是惰性队列。</p>
<p>惰性队列的特征如下:</p>
<ul>
<li><p>接收到消息后直接存入磁盘而非内存(内存中只保留最近的消息,默认2048条)</p>
</li>
<li><p>消费者要消费消息时才会从磁盘中读取并加载到内存</p>
</li>
<li><p>支持数百万条的消息存储</p>
</li>
</ul>
<p>在3.12版本后,所有队列都是Lazy Queue模式,无法更改。</p>
<p>与消息持久化不同，在写磁盘的时候做了IO优化，更加优秀。以下两种实现形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于Bean</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">        .durable (<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">        .lazy()<span class="comment">//开启Lazy模式</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于注解</span></span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">    name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">    durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">    arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息:&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者可靠性"><a href="#消费者可靠性" class="headerlink" title="消费者可靠性"></a>消费者可靠性</h3><h4 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h4><p>为了确认消费者是否成功处理消息,RabbitMQ提供了消费者确认机制(Consumer Acknowledgement)。当消费者处理消息结束后,应该向RabbitMQ发送一个回执,告知RabbitMQ自己消息处理状态。回执有三种可选值:</p>
<ul>
<li>ack:成功处理消息,RabbitMQ从队列中删除该消息</li>
<li>nack:消息处理失败,RabbitMQ需要再次投递消息</li>
<li>reject:消息处理失败并拒绝该消息,RabbitMQ从队列中删除该消息</li>
</ul>
<p>SpringAMQP已经实现了消息确认功能。并允许我们通过配置文件选择ACK处理方式,有三种方式:</p>
<ul>
<li>none:不处理。即消息投递给消费者后立刻ack,消息会立刻从MQ删除。非常不安全,不建议使用</li>
<li>manual:手动模式。需要自己在业务代码中调用api,发送ack或reject,存在业务入侵,但更灵活</li>
<li>auto:自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强,当业务正常执行时则自动返回ack.当业务出现异常时,根据异常判断返回不同结果:<ul>
<li>如果是业务异常,会自动返回nack</li>
<li>如果是消息处理或校验异常,自动遞回reject</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># none,关闭ack;manual,手动ack;auto:自动ack</span></span><br></pre></td></tr></table></figure>

<h4 id="消费失败处理"><a href="#消费失败处理" class="headerlink" title="消费失败处理"></a>消费失败处理</h4><p>当消费者出现异常后,消息会不断requeue(重新入队)到队列,再重新发送给消费者,然后再次异常,再次requeue,无限循环,导致mq的消息处理飙升,带来不必要的压力。<br>我们可以利用Spring的retry机制,在消费者出现异常时利用本地重试,而不是无限制的requeue到mq队列:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">  	<span class="attr">listener:</span></span><br><span class="line">	  <span class="attr">simple:</span></span><br><span class="line">		<span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">		<span class="attr">retry:</span></span><br><span class="line">		  <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">		  <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初始的失败等待时长为1秒</span></span><br><span class="line">		  <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 下次失败的等待时长倍数,下次等待时长= multiplier * last-interval</span></span><br><span class="line">		  <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">		  <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态;false有状态。如果业务中包含事务,这里改为false</span></span><br></pre></td></tr></table></figure>

<p>在开启重试模式后,重试次数耗尽,如果消息依然失败,则需要有MessageRecoverer接口来处理,它包含三种不同的实现:</p>
<ul>
<li><p>RejectAndDontRequeueRecoverer:重试耗尽后,直接reject,丢弃消息。默认就是这种方式</p>
</li>
<li><p>mmediateRequeueMessageRecoverer:重试耗尽后,返回nack,消息重新入队</p>
</li>
<li><p>RepublishMessageRecoverer:重试耗尽后,将失败消息投递到指定的交换机</p>
</li>
</ul>
<h4 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h4><p>幂等是一个数学概念，用函数式表达式来描述为：f(x)&#x3D;f(f(x))。在程序开发中，则认为同一个业务执行一次或多次对业务状态影响是一致的。比如查询、删除业务。</p>
<h5 id="方案一-唯一消息ID"><a href="#方案一-唯一消息ID" class="headerlink" title="方案一 唯一消息ID"></a>方案一 唯一消息ID</h5><p>给每个消息都设置一个唯一id,利用id区分是否是重复消息:</p>
<ol>
<li><p>每一条消息都生成一个唯一的id,与消息一起投递给消费者。</p>
</li>
<li><p>消费者接收到消息后处理自己的业务,业务处理成功后将消息ID保存到数据库</p>
</li>
<li><p>如果下次又收到相同消息,去数据库查询判断是否存在,存在则为重复消息放弃处理。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span> <span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 1.定义消息转换器</span></span><br><span class="line">	<span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">	<span class="comment">// 2.配置自动创建消息id,用于识别不同消息,也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">	jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方案二-业务判断"><a href="#方案二-业务判断" class="headerlink" title="方案二 业务判断"></a>方案二 业务判断</h5><p>结合业务逻辑,基于业务本身做判断。以我们的业务为例:我们要在支付后修改订单状态为已支付,应该在修改订单状态前先查询订单状态,判断状态是否是未支付。只有未支付订单才需要修改,其它状态不做处理，某些场景可以使用乐观锁。</p>
<h2 id="第三章-消息延迟"><a href="#第三章-消息延迟" class="headerlink" title="第三章 消息延迟"></a>第三章 消息延迟</h2><p>生产者发送消息时制定一个时间，消费者不会立刻收到消息，而是在指定时间之后收到消息。实现方案有两种，一种是死信交换机，另一种是延迟消息插件。消息延迟会造成性能损耗，所以用于延迟时间较短的业务场景。</p>
<h3 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h3><p>当一个队列中的消息满足下列情况之一时,就会成为死信(dead letter):</p>
<ul>
<li><p>消费者使用basic.reject或basic.nack声明消费失败,并且消息的requeue参数设置为false</p>
</li>
<li><p>消息是一个过期消息(达到了队列或消息本身设置的过期时间),超时无人消费</p>
</li>
<li><p>要投递的队列消息堆积满了,最早的消息可能成为死信</p>
</li>
</ul>
<p>如果队列通过dead-letter-exchange属性指定了一个交换机,那么该队列中的死信就会投递到这个交换机中。这个交<br>换机称为死信交换机(Dead Letter Exchange,简称DLX)。死信交换机需连接消费者。</p>
<h3 id="延迟消息插件"><a href="#延迟消息插件" class="headerlink" title="延迟消息插件"></a>延迟消息插件</h3><ol>
<li>首先下载插件rabbitmq_delayed_message_exchange，安装到RabbitMQ数据卷插件挂载的地方，重启MQ。</li>
<li>在Java客户端中声明特殊交换机</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于注解</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息:&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于Bean</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span> <span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">        .directExchange(<span class="string">&quot;delay.direct&quot;</span>)</span><br><span class="line">        .delayed()<span class="comment">// 设置delay的属性为true</span></span><br><span class="line">        .durable(<span class="literal">true</span>)<span class="comment">// 持久化</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSendDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend ( </span><br><span class="line">        exchange: <span class="string">&quot;delay.direct&quot;</span>, </span><br><span class="line">        routingKey: <span class="string">&quot;hi&quot;</span>, </span><br><span class="line">        message: <span class="string">&quot;hello&quot;</span>, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span> () &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    log.info(<span class="string">&quot;消息发送成功!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  </article>
  <!-- tag -->
  <div class="mt-12 pt-6 border-t border-gray-200">
    
      
        <span class="bg-gray-100 dark:bg-gray-700 px-2 py-1 m-1 text-sm rounded-md transition-colors hover:bg-gray-200">
          <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>
        </span>
      
    
  </div>
  <!-- prev and next -->
  <div class="flex justify-between mt-12 pt-6 border-t border-gray-200">
    <div>
      
        <a href="/2024/08/01/ES/" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          <iconify-icon width="20" icon="ri:arrow-left-s-line" data-inline="false"></iconify-icon>
          ElasticSeach
        </a>
      
    </div>
    <div>
      
        <a href="/2024/07/29/Git/" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          Git分布式版本控制
          <iconify-icon width="20" icon="ri:arrow-right-s-line" data-inline="false"></iconify-icon>
        </a>
      
    </div>
  </div>
  <!-- comment -->
  <div class="article-comments mt-12">
    

  </div>
</section>
<!-- js inspect -->

<script src="/lib/clipboard.min.js"></script>


<script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  $(document).ready(() => {
    const maraidConfig = {
      theme: "default",
      logLevel: 3,
      flowchart: { curve: "linear" },
      gantt: { axisFormat: "%m/%d/%Y" },
      sequence: { actorMargin: 50 },
    };
    mermaid.initialize(maraidConfig);
  });
</script>



<script src="/lib/fancybox/fancybox.umd.min.js"></script>

<script>
  $(document).ready(() => {
    $('.post-content').each(function(i){
      $(this).find('img').each(function(){
        if ($(this).parent().hasClass('fancybox') || $(this).parent().is('a')) return;
        var alt = this.alt;
        if (alt) $(this).after('<span class="fancybox-alt">' + alt + '</span>');
        $(this).wrap('<a class="fancybox-img" href="' + this.src + '" data-fancybox=\"gallery\" data-caption="' + alt + '"></a>')
      });
      $(this).find('.fancybox').each(function(){
        $(this).attr('rel', 'article' + i);
      });
    });

    Fancybox.bind('[data-fancybox="gallery"]', {
        // options
    })
  })
</script>

<!-- tocbot begin -->

<script src="/lib/tocbot/tocbot.min.js"></script>

<script>
  $(document).ready(() => {
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '.post-toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '.post-content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h1, h2, h3',
        // For headings inside relative or absolute positioned containers within content.
        hasInnerContainers: true,
    });
  })
</script>
<!-- tocbot end -->


  </main>
  <footer class="flex flex-col h-40 items-center justify-center text-gray-400 text-sm">
  <!-- busuanzi -->
  
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- Busuanzi Analytics -->
<div class="flex items-center gap-2">
  <span>Visitors</span>
  <span id="busuanzi_value_site_uv"></span>
  <span>Page Views</span>
  <span id="busuanzi_value_site_pv"></span>
</div>
<!-- End Busuanzi Analytics -->


  <!-- copyright -->
  <div class="flex items-center gap-2">
    <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color: inherit;">CC BY-NC-SA 4.0</a>
    <span>© 2022</span>
    <iconify-icon width="18" icon="emojione-monotone:maple-leaf" ></iconify-icon>
    <a href="https://github.com/xbmlz" target="_blank" rel="noopener noreferrer">xbmlz</a>
  </div>
  <!-- powered by -->
  <div class="flex items-center gap-2">
    <span>Powered by</span>
    <a href="https://hexo.io/" target="_blank" rel="noopener noreferrer">Hexo</a>
    <span>&</span>
    <a href="https://github.com/xbmlz/hexo-theme-maple" target="_blank" rel="noopener noreferrer">Maple</a>
  </div>

</footer>

  <div class="back-to-top box-border fixed right-6 z-1024 -bottom-20 rounded py-1 px-1 bg-slate-900 opacity-60 text-white cursor-pointer text-center dark:bg-slate-600">
    <span class="flex justify-center items-center text-sm">
      <iconify-icon width="18" icon="ion:arrow-up-c" id="go-top"></iconify-icon>
      <span id="scrollpercent"><span>0</span> %</span>
    </span>
  </div>
  
<script src="/js/main.js"></script>


  <script>
    $(document).ready(function () {
      const mapleCount = "10";
      const speed = "0.5";
      const mapleEl = document.getElementById("maple");
      const maples = Array.from({ length: mapleCount }).map(() => {
        const maple = document.createElement("div");
        const scale = Math.random() * 0.5 + 0.5;
        const offset = Math.random() * 2 - 1;
        const x = Math.random() * mapleEl.clientWidth;
        const y = -Math.random() * mapleEl.clientHeight;
        const duration = 10 / speed;
        const delay = -duration;
        maple.className = "maple";
        maple.style.width = `${24 * scale}px`;
        maple.style.height = `${24 * scale}px`;
        maple.style.left = `${x}px`;
        maple.style.top = `${y}px`;
        maple.style.setProperty("--maple-fall-offset", offset);
        maple.style.setProperty("--maple-fall-height", `${Math.abs(y) + mapleEl.clientHeight}px`);
        maple.style.animation = `fall ${duration}s linear infinite`;
        maple.style.animationDelay = `${delay}s`;
        mapleEl.appendChild(maple)
        return maple
      })
    });
  </script>
  


  <div class="fixed top-0 bottom-0 left-0 right-0 pointer-events-none print:hidden" id="maple"></div>
</body>

</html>
